// Copyright 2022 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package teescan

import (
	"database/sql/driver"
	"encoding/hex"
	"fmt"
	"strings"
	"sync"
	"time"
)

var pool = sync.Pool{New: func() interface{} { return new(Scanner) }}

// Scanner provides a convenient interface for getting string representation of
// the SQL parameters by slice of the parameters from database/sql/driver.
// Successive calls to the Scan method will step through the name and
// ordinal position of the parameter identifier and parameter value.
//
// The specification of a parameter value is defined by a Assert function of
// type AssertFunc; the default Assert function provides access to an
// string representation of the SQL parameter.
//
// Scanning stops unrecoverably at the first error.
//
type Scanner struct {
	Values      []driver.Value      // Non named/non ordinal parameters in database/sql/driver representation.
	NamedValues []driver.NamedValue // Named or ordinal parameters in database/sql/driver representation.
	Assert      AssertFunc          // The function to get string representation of the SQL parameter.
	Reverse     bool                // Scans parameters from ending to beginning
	dirty       bool                // Scan has been called.
	name        string              // Last name of the parameter identifier geted by scanner.
	ordinal     int                 // Last ordinal position of the parameter identifier geted by scanner.
	value       string              // Last parameter value returned by Assert function.
	idx         int                 // Current index of slice of the non named/non ordinal parameters or of the named or ordinal parameters.
	max         int                 // Maximum index of slice of the non named/non ordinal parameters or of the named or ordinal parameters.
	err         error               // Sticky error.
}

// AssertFunc is the signature of the function used to assert type of
// the parameter value. The argument are an untyped SQL parameter value.
// The return value are string representation of the SQL parameter
// appropriate for the substitution into the plain SQL query.
//
// Scanning stops if the function returns an error.
//
type AssertFunc func(interface{}) (string, error)

func GetScanner() *Scanner {
	s := pool.Get().(*Scanner)
	s.Values = s.Values[:0]
	s.NamedValues = s.NamedValues[:0]
	s.Assert = ValueString
	s.Reverse = false
	s.dirty = false
	s.idx = 0
	s.max = 0
	return s
}

func PutScanner(s *Scanner) {
	pool.Put(s)
}

// Err returns the first error that was encountered by the Scanner.
func (s *Scanner) Err() error {
	return s.err
}

// Param returns the most recent name and ordinal position of
// the parameter identifier and string representation of the SQL parameter value
// generated by a call to Scan.
//
// If the name is not empty it should be used for the parameter identifier and
// not the ordinal position.
//
// If name of the parameter identifier is empty and ordinal position is
// equal to zero therefore SQL query contains non named/non ordinal
// parameter identifiers (for example ? question characters).
func (s *Scanner) Param() (string, int, string) {
	return s.name, s.ordinal, s.value
}

func (s *Scanner) Scan() bool {
	s.name = ""
	s.ordinal = 0
	s.value = ""
	s.err = nil

	if !s.dirty {
		if len(s.Values) != 0 {
			s.max = len(s.Values)
		} else if len(s.NamedValues) != 0 {
			s.max = len(s.NamedValues)
		}
		s.max--
	}

	s.dirty = true

	i := s.idx
	if s.Reverse {
		i = s.max - s.idx
	}

	if s.idx > s.max {
		return false
	}

	s.idx++

	if len(s.Values) != 0 {
		s.value, s.err = s.Assert(s.Values[i])

		return s.err == nil
	} else if len(s.NamedValues) != 0 {
		s.name = s.NamedValues[i].Name
		s.ordinal = s.NamedValues[i].Ordinal
		s.value, s.err = s.Assert(s.NamedValues[i].Value)

		return s.err == nil
	}

	return false
}

// ValueString is a type assertion function for a Scanner that receives
// untyped SQL parameter value and returns string representation of
// the SQL parameter appropriate for the substitution into the plain SQL query.
func ValueString(value interface{}) (string, error) {
	switch v := value.(type) {
	case int, int32, int64, float32, float64:
		return fmt.Sprint(v), nil

	case *int:
		if v == nil {
			return "NULL", nil
		}
		return fmt.Sprint(*v), nil

	case *int32:
		if v == nil {
			return "NULL", nil
		}
		return fmt.Sprint(*v), nil

	case *int64:
		if v == nil {
			return "NULL", nil
		}
		return fmt.Sprint(*v), nil

	case *float32:
		if v == nil {
			return "NULL", nil
		}
		return fmt.Sprint(*v), nil

	case *float64:
		if v == nil {
			return "NULL", nil
		}
		return fmt.Sprint(*v), nil

	case bool:
		return strings.ToUpper(fmt.Sprint(v)), nil

	case *bool:
		if v == nil {
			return "NULL", nil
		}
		return strings.ToUpper(fmt.Sprint(*v)), nil

	case []byte:
		return bytea(v), nil

	case *[]byte:
		if v == nil {
			return "NULL", nil
		}
		return bytea(*v), nil

	case string:
		return fmt.Sprintf("'%s'", v), nil

	case *string:
		if v == nil {
			return "NULL", nil
		}
		return fmt.Sprintf("'%s'", *v), nil

	case time.Time:
		return time3339(v), nil

	case *time.Time:
		if v == nil {
			return "NULL", nil
		}
		return time3339(*v), nil

	default:
		return "", fmt.Errorf("invalid type %T of the parameter value: %v", v, v)
	}
}

func time3339(t time.Time) string {
	return fmt.Sprintf("'%s'", t.Format(time.RFC3339))
}

// bytea hex format <https://www.postgresql.org/docs/current/datatype-binary.html#id-1.5.7.12.9>.
func bytea(p []byte) string {
	dst := make([]byte, hex.EncodedLen(len(p)))
	hex.Encode(dst, p)
	return fmt.Sprintf("E'\\\\x%s'", dst)
}
